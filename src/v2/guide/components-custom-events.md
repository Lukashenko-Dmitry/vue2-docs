---
title: Спеціальні події
type: guide
order: 103
---

> Даний розділ передбачає, що ви вже знайомі [компонентами](components.html). Прочитайте його, якщо це не так.

<div class="vueschool"><a href="https://vueschool.io/lessons/communication-between-components?friend=vuejs" target="_blank" rel="sponsored noopener" title="Дізнайтеся, як працювати із спеціальними подіями в Vue School">Дізнайтеся, як працювати із спеціальними подіями на безкоштовному уроці в Vue School lesson</a></div>

## Імена подій

На відміну від компонентів та вхідних параметрів, імена подій не трансформуються автоматично. Навпаки, ім'я згенерованої події має бути точно таким самим, як і ім'я, що використовується для її відстежування. Ось приклад, якщо згенероване ім'я події в стилі camelCase:

```js
this.$emit('myEvent')
```

Відстежуванні події за її іменем в стилі kebab-cased не працюватиме:

```html
<!-- Це не працюватиме -->
<my-component v-on:my-event="doSomething"></my-component>
```

На відміну від компонентів та вхідних параметрів, імена подій не будуть використовуватися як змінна або властивість в JavaScript, тому нема змісту використовувати camelCase чи PascalCase. Крім того, слухач подій `v-on` всередині DOM шаблонів будуть автоматично трансформовані до нижнього регістру (у зв'язку з ігноруванням регістру в стандарті HTML), тому `v-on:myEvent` стане `v-on:myevent`, роблячи `myEvent` неможливим для відстежування.

З цих причин, ми радимо вам **завжди задавати імена подій в стилі kebab-case**.

## Власне налаштування `v-model` компоненту

> Нове в 2.2.0+

За замовчуванням, `v-model` в компонента використовує `value` як вхідний параметр та `input` як ім'я події, але деякі типи елементів введення, такі як прапорці та радіо кнопки можуть використовувати атрибут `value` [різних потреб](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/checkbox#Value). Використання параметру `model` може запобігти конфліктів у випадках:

```js
Vue.component('base-checkbox', {
  model: {
    prop: 'checked',
    event: 'change'
  },
  props: {
    checked: Boolean
  },
  template: `
    <input
      type="checkbox"
      v-bind:checked="checked"
      v-on:change="$emit('change', $event.target.checked)"
    >
  `
})
```

Тепер при використанні у цьому компоненті `v-model`:

```html
<base-checkbox v-model="lovingVue"></base-checkbox>
```

значення властивості `lovingVue` буде передане до вхідного параметра `checked`. Властивість `lovingVue` буде оновлена згодом, коли `<base-checkbox>` згенерує подію `change` із новим значенням.

<p class="tip">Зверніть увагу, що ви все одно повинні оголосити вхідний параметр <code>checked</code> в об'єкті <code>props</code> компонента.</p>

## Зв'язування рідних подій в компоненті

Інколи може виникати необхідність, коли ви хочете відстежувати рідну подію на кореневому елементі компонента. В такому разі, ви можете використовувати модифікатор `.native` при`v-on`:

```html
<base-input v-on:focus.native="onFocus"></base-input>
```

Це інколи може бути корисним, але не є найкращою ідеєю при спробі відстежування на якомусь конкретному елементі, наприклад `<input>`. Для прикладу, компонент `<base-input>`, що вище можна змінити таким чином, що кореневим елементом буде `<label>`:

```html
<label>
  {{ label }}
  <input
    v-bind="$attrs"
    v-bind:value="value"
    v-on:input="$emit('input', $event.target.value)"
  >
</label>
```

В даному випадку, слухач `.native` в батьківському компоненті просто тихо зламається. Не буде ніяких помилок, але обробник `onFocus` не буде викликаний, як це очікувалось.

Для розв'язання цієї проблеми, Vue пропонує властивість `$listeners`, яка містить об'єкт слухачів, які використовуються в компоненті. Наприклад:

```js
{
  focus: function (event) { /* ... */ }
  input: function (value) { /* ... */ },
}
```

Використовуючи властивість `$listeners`, ви можете переадресувати всі слухачі компонента специфічному дочірньому елементу за допомогою `v-on="$listeners"`. Для елементів, подібних до `<input>`, які також можуть працювати з `v-model`, часто корисно створювати нову обчислювану властивість для слухачів, як-от `inputListeners`:

```js
Vue.component('base-input', {
  inheritAttrs: false,
  props: ['label', 'value'],
  computed: {
    inputListeners: function () {
      var vm = this
      // `Object.assign` формує новий об'єкт, об'єднуючи об'єкти разом
      return Object.assign({},
        // Додаємо всіх слухачів з батьківського компонента
        this.$listeners,
        // Тепер ми можемо додати власних слухачів або перезаписати
        // поведінку деяких наявних слухачів.
        {
          // Таким чином, ми переконаємося, що компонент працює v-model
          input: function (event) {
            vm.$emit('input', event.target.value)
          }
        }
      )
    }
  },
  template: `
    <label>
      {{ label }}
      <input
        v-bind="$attrs"
        v-bind:value="value"
        v-on="inputListeners"
      >
    </label>
  `
})
```

Тепер компонент `<base-input>` є **повністю прозорою обгорткою**, маючи на увазі, що він може використовуватися як і звичайний елемент `<input>`: всі ті ж атрибути та слухачі працюватимуть навіть без модифікатора `.native`.

## Модифікатор `.sync`

> Нове в 2.3.0+

В деяких випадках може виникнути потреба використовувати "двонаправлене зв'язування" для вхідного параметра. Правда у тім, що, на жаль, таке зв'язування може створити певні проблеми з обслуговуванням, оскільки дочірні компоненти можуть мутувати батьківські без очевидного розуміння джерела такої мутації для батьківського та дочірнього компонента.

Ось чому ви радимо генерувати події у вигляді `update:myPropName`. Для прикладу, в гіпотетичного компонента із вхідним параметром `title`, ми можемо повідомити про намір присвоєння нового значення за допомогою:

```js
this.$emit('update:title', newTitle)
```

Потім, батьківський компонент може прослуховувати цю подію та оновити локальну властивість даних, якщо йому це потрібно. Наприклад:

```html
<text-document
  v-bind:title="doc.title"
  v-on:update:title="doc.title = $event"
></text-document>
```

Для зручності, ми пропонуємо скорочення для цієї техніки — модифікатор `.sync`:

```html
<text-document v-bind:title.sync="doc.title"></text-document>
```

<p class="tip">Зверніть увагу, що <code>v-bind</code> із модифікатором <code>.sync</code> <strong>не</strong> працює з виразами (тобто, <code>v-bind:title.sync="doc.title + '!'"</code> є невірним). Тому, ви повинні вказувати лише ім'я властивості, яку ви хочете прив'язати, подібно до <code>v-model</code>.</p>

Модифікатор `.sync` може також використовуватись разом з `v-bind` при використанні об'єкта для задавання кількох властивостей за раз:

```html
<text-document v-bind.sync="doc"></text-document>
```

Це передає кожну властивість в об'єкті `doc` (тобто, `title`) як окремий вхдний параметр, потім додаючи слухач `v-on` для кожної з них.

<p class="tip">Застосування <code>v-bind.sync</code> з літеральним об'єктом, як, наприклад, через <code>v-bind.sync="{ title: doc.title }"</code>, не працюватиме, оскільки існує забагато крайніх випадків, необхідних для прийняття до уваги при розборі складного виразу, такого, як цей.</p>
