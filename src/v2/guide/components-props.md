---
title: Вхідні параметри
type: guide
order: 102
---

> Цей розділ передбачає ваше розуміння [базових знань компонентів](components.html). Прочитайте його перед тим, як знайомитися з цим розділом.

<div class="vueschool"><a href="https://vueschool.io/lessons/reusable-components-with-props?friend=vuejs" target="_blank" rel="sponsored noopener" title="Дізнайтеся, як працюють вхідні параметри у Vue School">Дізнайтеся, як працюють вхідні параметри на безкоштовному уроці у Vue School</a></div>

## Регістр вхідних параметрів (camelCase чи kebab-case)

Імена HTML атрибутів не залежать від регістру, тому браузери розумітимуть будь-які символи ви верхньому регістрі як символи в нижньому. Це означає, що коли ви використовуєте шаблони, створені як частина DOM, імена властивостей, написані в стилі camelCase мають бути використані їхні kebab-case еквіваленти (розділені через дефіс):

``` js
Vue.component('blog-post', {
  // camelCase в JavaScript
  props: ['postTitle'],
  template: '<h3>{{ postTitle }}</h3>'
})
```

``` html
<!-- kebab-case в HTML -->
<blog-post post-title="hello!"></blog-post>
```

Знову ж таки, ці обмеження не впливають, якщо ви використовуєте рядкові шаблони.

## Типи вхідних параметрів

До цього моменту, ми тільки розглядали вхідні параметри, перелічені як масив рядкових величин:

```js
props: ['title', 'likes', 'isPublished', 'commentIds', 'author']
```

Проте, зазвичай ви б хотіли, щоб кожен вхідний параметр мав якийсь специфічний тип очікуваного значення. В таких випадках ви можете перелічити вхідні параметри у вигляді об'єкту, де імена його властивостей та значень матимуть відповідно їхні імена та їхні типи:

```js
props: {
  title: String,
  likes: Number,
  isPublished: Boolean,
  commentIds: Array,
  author: Object,
  callback: Function,
  contactsPromise: Promise // або будь-який інший конструктор
}
```

Це не лише документує ваш компонент, але також попередить користувачів в консолі JavaScript браузера, якщо вони передадуть невірний тип. Ви дізнаєтесь більше про [перевірку типів та іншу валідацію вхідних параметрів](#Валідація-вхідних-параметрів) на цій сторінці трохи нижче.

## Передача статичних або динамічних вхідних параметрів

До цього моменту, ви тільки спостерігали за вхідними параметрами, переданими як статичне значення, наприклад:

```html
<blog-post title="Мій шлях з Vue"></blog-post>
```

Ми також бачили вхідні параметри, передані динамічно за допомогою `v-bind`, як в наступному прикладі:

```html
<!-- Динамічна передача значення через змінну -->
<blog-post v-bind:title="post.title"></blog-post>

<!-- Динамічне передача значення через складний вираз -->
<blog-post
  v-bind:title="post.title + ', автор: ' + post.author.name"
></blog-post>
```

В цих двох прикладах, що зверху, нам вдавалося передавати рядкові значення, але насправді _будь-які_ типи значення можуть передані до вхідного параметра.

### Передача числа

```html
<!-- Хоч `42` є статичним, ми повинні використовувати v-bind, щоб вказати Vue, що -->
<!-- це є виразом JavaScript, а не рядкове значення. -->
<blog-post v-bind:likes="42"></blog-post>

<!-- Динамічна передача значення через змінну. -->
<blog-post v-bind:likes="post.likes"></blog-post>
```

### Передача булевого значення

```html
<!-- Додавання булевого вхідного параметру без значення означатиме булеве значення `true`. -->
<blog-post is-published></blog-post>

<!-- Хоча `false` і статичне, ми повинні використовувати v-bind, щоб вказати Vue, що -->
<!-- це є виразом JavaScript, а не рядкове значення. -->
<blog-post v-bind:is-published="false"></blog-post>

<!-- Динамічна передача значення через змінну. -->
<blog-post v-bind:is-published="post.isPublished"></blog-post>
```

### Передача масиву

```html
<!-- Хоча масив і статичний, ми повинні використовувати v-bind, щоб вказати Vue, що -->
<!-- це є виразом JavaScript, а не рядкове значення. -->
<blog-post v-bind:comment-ids="[234, 266, 273]"></blog-post>

<!-- Динамічна передача значення через змінну. -->
<blog-post v-bind:comment-ids="post.commentIds"></blog-post>
```

### Передача об'єкту

```html
<!-- Хоча об'єкт і статичний, ми повинні використовувати v-bind, щоб вказати Vue, що -->
<!-- це є виразом JavaScript, а не рядкове значення. -->
<blog-post
  v-bind:author="{
    name: 'Veronica',
    company: 'Veridian Dynamics'
  }"
></blog-post>

<!-- Динамічна передача значення через змінну. -->
<blog-post v-bind:author="post.author"></blog-post>
```

### Передача властивостей об'єкту

Якщо ви хотіли б передати всі властивості об'єкту, як вхідні параметри, ви можете скористатися `v-bind` без аргументу (`v-bind` замість `v-bind:prop-name`). Для прикладу, в нас є об'єкт `post`:

``` js
post: {
  id: 1,
  title: 'Мій шлях з Vue'
}
```

Наступний шаблон:

``` html
<blog-post v-bind="post"></blog-post>
```

Еквівалентний наступному:

``` html
<blog-post
  v-bind:id="post.id"
  v-bind:title="post.title"
></blog-post>
```

## Односторонній перебіг даних

Всі вхідні параметри формують **односторонній зв'язок** між дочірніми властивостями та батьківським: коли батьківська властивість змінюється, це перейде вниз аж до дочірніх, але не навпаки. Це запобігає дочірні компоненти випадково мутувати стан батьківських, щоб могло б зробити перебіг даних вашого застосунку складнішим для розуміння.

Крім того, щоразу, коли батьківський компонент оновлено, всі вхідні параметри дочірнього компоненту будуть оновлені автоматично новими значеннями. Це означає, що ви **не** повинні намагатися мутувати вхідний параметр усередині дочірньої компоненти. Якщо ж ви спробуєте це зробити, Vue попередить вас в консолі розробника.

Як правило, існує два випадки, де хочеться змінити вхідний параметр:

1. **Вхідний параметр використовується для передачі початкового значення; після чого, дочірній компонент використовуватиме його як локальну властивість даних.** В даному випадку, найкраще оголошувати локальну властивість даних, яка використовуватиме вхідний параметр з його початковим значенням:

  ``` js
  props: ['initialCounter'],
  data: function () {
    return {
      counter: this.initialCounter
    }
  }
  ```

2. **Вхідний параметр містить початкове значення, що підлягає перетворення.** В даному випадку, найкраще оголосити обчислювану властивість, що використовує значення вхідного параметра:

  ``` js
  props: ['size'],
  computed: {
    normalizedSize: function () {
      return this.size.trim().toLowerCase()
    }
  }
  ```

<p class="tip">Зверніть увагу, що об'єкти та масиви в JavaScript передаються по посиланню, тому, якщо вхідний параметр є масивом або об'єктом, мутація масиву або об'єкту всередині дочірнього компоненту **спричинить** мутацію батьківського стану даних.</p>

## Валідація вхідних параметрів

Компоненти можуть вказувати вимоги для своїх вхідних параметрів, для типів, які ви вже бачили. Якщо вимога не задоволена, Vue попередить вас в консолі розробника JavaScript у браузері. Це особливо корисно при розробці компонентів, призначених для використання іншими.

Для активування валідації певного вхідного параметра, ви можете вказати об'єкт з вимогами щодо валідації до вхідного параметру для властивості `props`, замість простого масиву рядкових величин. Наприклад:

``` js
Vue.component('my-component', {
  props: {
    // Проста перевірка типу (`null` та `undefined` пройдуть валідацію будь-якого типу)
    propA: Number,
    // Декілька можливих типів
    propB: [String, Number],
    // Рядковий тип, обов'язковий
    propC: {
      type: String,
      required: true
    },
    // Число із значенням по замовчуванню
    propD: {
      type: Number,
      default: 100
    },
    // Об'єкт із значенням по замовчуванню
    propE: {
      type: Object,
      // Значення по замовчуванню для об'єктів або масивів повинні
      // використовувати функцію-фабрику
      default: function () {
        return { message: 'привіт' }
      }
    },
    // Власна функція валідації
    propF: {
      validator: function (value) {
        // Значення має бути одним з наступних:
        return ['помилка', 'попередження', 'небезпека'].indexOf(value) !== -1
      }
    }
  }
})
```

При помилці валідації вхідного параметра Vue згенерує попередження в консолі (при використанні збірки для розробників).

<p class="tip">Врахуйте, що валідація вхідних параметрів виконується **перед тим**, як екземпляр компонента було створено, тому властивості екземпляру (такі як `data`, `computed`, і т. д.) не будуть доступними в функціях `default` та `validator`.</p>

### Перевірка типів

Значення властивості `type` може бути одним з наступних конструкторів JavaScript:

- String
- Number
- Boolean
- Array
- Object
- Date
- Function
- Symbol

Крім того, `type` може бути також і власною функцією-конструктором — в такому разі перевірка буде здійснюватися через оператор `instanceof`. Розглянемо приклад з наступною функцією-конструктором:

```js
function Person (firstName, lastName) {
  this.firstName = firstName
  this.lastName = lastName
}
```

Ви можете її використовувати наступним чином:

```js
Vue.component('blog-post', {
  props: {
    author: Person
  }
})
```

Таким чином, ви можете перевіряти, що вхідний параметр `author` було створено за допомогою `new Person`.

## Атрибути, що не є вхідними параметрами

Атрибут, що не є вхідним параметром — це атрибут, який було передано до компонента, але його не було оголошено як вхідного параметра.

Хоча явне оголошення вхідних параметрів вважається кращим способом для передачі інформації до компонента, автори бібліотек компонентів не завжди можуть передбачити контекст, де той чи інший компонент буде використовуватися. Тому компоненти можуть приймати будь-які атрибути, які просто будуть додані до кореневого елемента компоненти.

For example, уявіть, що ми використовуємо сторонній компонент `bootstrap-date-input` з плагіном Bootstrap, що вимагає атрибут `data-date-picker` для елементу `input`. Ми можемо додати цей атрибут до компонента:

``` html
<bootstrap-date-input data-date-picker="activated"></bootstrap-date-input>
```

Таким чином, атрибут `data-date-picker="activated"` буде додано до кореневого елемента `bootstrap-date-input`.

### Об'єднання/заміна наявних атрибутів

Уявіть, що це шаблон для `bootstrap-date-input`:

``` html
<input type="date" class="form-control">
```

Щоб вказати тему для нашого плагіну вибору дати, нам потрібно додати специфічний клас, наприклад:

``` html
<bootstrap-date-input
  data-date-picker="activated"
  class="date-picker-theme-dark"
></bootstrap-date-input>
```

В даному випадку, для `class` задаються два значення:

- `form-control`, який задається самим компонентом в шаблоні
- `date-picker-theme-dark`, який передається компоненту батьківським

Для більшості атрибутів значення, передане до компонента замінить значення, встановлене самим компонентом. Наприклад, передане `type="text"` замінить `type="date"` і, ймовірно, зламає його! На щастя, атрибути `class` та `style` дещо розумніші, тому обидва атрибути будуть об'єднані, тому кінцеве значення буде таким: `form-control date-picker-theme-dark`.

### Заборона наслідування атрибутів

Якщо ви **не** хочете, щоб кореневий елемент компонента наслідував атрибутів, ви можете задати `inheritAttrs: false` у властивостях компонента. Для прикладу:

```js
Vue.component('my-component', {
  inheritAttrs: false,
  // ...
})
```

Це особливо корисно при комбінації з властивістю екземпляру `$attrs`, що містить імена атрибутів та їхні значення, передані до компонента наступним чином:

```js
{
  required: true,
  placeholder: "Вкажіть своє ім'я"
}
```

Завдяки `inheritAttrs: false` та `$attrs`, ви можете власноруч вирішувати, якому елементу ви хотіли б передавати атрибути, що часто необхідно для [іменування базових компонент](../style-guide/#Імена-базових-компонент-настійно-рекомендовано):

```js
Vue.component('base-input', {
  inheritAttrs: false,
  props: ['label', 'value'],
  template: `
    <label>
      {{ label }}
      <input
        v-bind="$attrs"
        v-bind:value="value"
        v-on:input="$emit('input', $event.target.value)"
      >
    </label>
  `
})
```

<p class="tip">Майте на увазі, що `inheritAttrs: false` **не** вплине на `style` та `class`.</p>

Ця техніка дозволяє використовувати базові компоненти більше як звичайні HTML компоненти, не турбуючись про те, який саме елемент буде кореневим:

```html
<base-input
  v-model="username"
  required
  placeholder="Вкажіть своє ім'я"
></base-input>
```
